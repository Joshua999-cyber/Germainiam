<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pixel Shooter — Germainiam</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    :root {
      --scale: 4; /* will be updated by JS for integer scaling */
      --bg: #0b0f1a;
      --fg: #e6f0ff;
      --accent: #ff6b6b;
    }
    html,body{
      height:100%;
      margin:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(180deg,#021428 0%, #00121b 100%);
      color:var(--fg);
      font-family:monospace;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      overscroll-behavior: none;
    }
    #game-wrap{
      display:inline-block;
      text-align:center;
      width: calc(160px * var(--scale));
    }
    /* Canvas scaled using CSS for pixelated look */
    canvas{
      image-rendering: pixelated;
      background: var(--bg);
      width: calc(160px * var(--scale));
      height: calc(144px * var(--scale));
      border: 4px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 30px rgba(0,0,0,0.7);
      display:block;
      margin: 0 auto 8px;
      touch-action: none; /* allow touchmove handling on canvas */
    }
    .hud{
      display:flex;
      justify-content:space-between;
      gap:8px;
      color: #cfe9ff;
      font-size: 12px;
    }
    .controls{
      margin-top:8px;
      font-size:11px;
      color:#a8c8ff;
      opacity:0.9;
    }
    .muted{ color: #7698b8; }
    button {
      margin-left:8px;
      background:transparent;
      color:var(--fg);
      border:1px solid rgba(255,255,255,0.06);
      padding:4px 8px;
      cursor:pointer;
      font-family:monospace;
    }

    /* Mobile controls (visible on small screens / touch) */
    .mobile-controls{
      display:none;
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:12px;
      gap:12px;
      z-index:40;
      align-items:center;
      justify-content:center;
      pointer-events: auto;
    }
    .mobile-controls button{
      width:68px;
      height:68px;
      border-radius:12px;
      background: rgba(255,255,255,0.06);
      color: var(--fg);
      font-size:28px;
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      -webkit-user-select:none;
      user-select:none;
    }
    .mobile-controls .shoot{
      background: linear-gradient(180deg, rgba(255,80,80,0.95), rgba(255,40,40,0.9));
      color: white;
      font-size:22px;
      width:82px;
      height:82px;
      border-radius:42px;
    }
    .mobile-controls .restart{
      width:54px;
      height:54px;
      border-radius:10px;
      font-size:20px;
      background: rgba(255,255,255,0.04);
    }

    /* Show mobile controls on small screens / touch devices */
    @media (max-width: 700px), (pointer:coarse) {
      #game-wrap{ width: calc(100vw - 32px); }
      canvas{
        width: calc(160px * var(--scale));
        height: calc(144px * var(--scale));
        max-width: 100%;
      }
      .controls{ display:none; } /* hide keyboard hint area */
      .mobile-controls{ display:flex; }
      .hud{ font-size:13px; padding: 0 8px; }
    }

    /* Landscape layout adjustment */
    @media (orientation:landscape) and (max-height: 420px) {
      .mobile-controls{ bottom:8px; }
      .mobile-controls button{ width:60px; height:60px; font-size:22px; }
      .mobile-controls .restart{ width:48px; height:48px; }
    }
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="screen" width="160" height="144" aria-label="Pixel shooter canvas"></canvas>
    <div class="hud" aria-hidden="false">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
      <div>Wave: <span id="wave">1</span></div>
    </div>
    <div class="controls">
      ← / A, → / D: move &nbsp; • &nbsp; Space: shoot &nbsp; • &nbsp; P: pause &nbsp; • &nbsp; R: restart
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <!-- Mobile overlay controls -->
  <div class="mobile-controls" id="mobileControls" aria-hidden="true">
    <button id="btnLeft" aria-label="Move left">◀</button>
    <button id="btnShoot" class="shoot" aria-label="Shoot">●</button>
    <button id="btnRight" aria-label="Move right">▶</button>
    <button id="btnRestart" class="restart" aria-label="Restart">⟲</button>
  </div>

  <script>
    // Simple pixel shooter (mobile-friendly enhancements + on-screen restart)
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const waveEl = document.getElementById('wave');
    const restartBtn = document.getElementById('restartBtn');

    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnShoot = document.getElementById('btnShoot');
    const btnRestart = document.getElementById('btnRestart');

    const W = canvas.width;   // 160
    const H = canvas.height;  // 144

    // Game state
    let keys = {};
    let lastShot = 0;
    let gamePaused = false;
    let running = true;

    const player = {
      x: W/2 - 6,
      y: H - 16,
      w: 12,
      h: 8,
      speed: 1.8,
      cooldown: 200, // ms between shots
    };

    let bullets = []; // player bullets
    let enemies = [];
    let enemyBullets = [];
    let spawnTimer = 0;
    let spawnInterval = 1200;
    let score = 0;
    let lives = 3;
    let wave = 1;
    let lastTime = performance.now();

    function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

    function resetGame() {
      bullets = [];
      enemies = [];
      enemyBullets = [];
      spawnTimer = 0;
      spawnInterval = 1200;
      score = 0;
      lives = 3;
      wave = 1;
      player.x = W/2 - player.w/2;
      lastShot = 0;
      running = true;
      gamePaused = false;
      updateHUD();
    }

    function updateHUD(){
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      waveEl.textContent = wave;
    }

    // Spawn a wave of enemies based on wave number
    function spawnEnemyRow(count) {
      const margin = 8;
      const spacing = Math.floor((W - margin*2) / count);
      for(let i=0;i<count;i++){
        enemies.push({
          x: margin + i*spacing + (spacing/2 - 6),
          y: -10 - rand(0,40),
          w: 12,
          h: 8,
          vx: (i%2===0?0.3:-0.3),
          vy: 0.15 + wave*0.02,
          hp: 1 + Math.floor(wave/3),
          shootChance: 0.003 + wave*0.0008
        });
      }
    }

    // Basic AABB collision
    function collides(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function update(dt){
      if(!running || gamePaused) return;

      // player movement
      if(keys['ArrowLeft'] || keys['a'] || keys['A']) player.x -= player.speed * dt;
      if(keys['ArrowRight'] || keys['d'] || keys['D']) player.x += player.speed * dt;
      player.x = Math.max(0, Math.min(W - player.w, player.x));

      // shooting
      if((keys[' '] || keys['Space']) && performance.now() - lastShot > player.cooldown){
        bullets.push({ x: player.x + player.w/2 - 1, y: player.y - 4, w:2, h:4, vy: -2.6 });
        lastShot = performance.now();
      }

      // update bullets
      for(let i=bullets.length-1;i>=0;i--){
        bullets[i].y += bullets[i].vy * dt;
        if(bullets[i].y + bullets[i].h < 0) bullets.splice(i,1);
      }

      // update enemy bullets
      for(let i=enemyBullets.length-1;i>=0;i--){
        enemyBullets[i].y += enemyBullets[i].vy * dt;
        if(enemyBullets[i].y > H) enemyBullets.splice(i,1);
      }

      // update enemies
      for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        e.x += e.vx * dt;
        e.y += e.vy * dt;
        // bounce
        if(e.x < 0 || e.x + e.w > W) e.vx *= -1;

        // random shooting
        if(Math.random() < e.shootChance * dt){
          enemyBullets.push({ x: e.x + e.w/2 - 1, y: e.y + e.h, w:2, h:4, vy: 1.6 + wave*0.1 });
        }

        // remove if off bottom
        if(e.y > H){
          enemies.splice(i,1);
          lives -= 1;
          updateHUD();
          if(lives <= 0) {
            running = false;
          }
        }
      }

      // bullet <> enemy collisions
      for(let i=enemies.length-1;i>=0;i--){
        for(let j=bullets.length-1;j>=0;j--){
          if(collides(enemies[i], bullets[j])){
            enemies[i].hp -= 1;
            bullets.splice(j,1);
            if(enemies[i].hp <= 0){
              // explode (score)
              score += 10;
              enemies.splice(i,1);
              updateHUD();
              break;
            }
          }
        }
      }

      // enemy bullet <> player
      for(let i=enemyBullets.length-1;i>=0;i--){
        if(collides(enemyBullets[i], player)){ 
          enemyBullets.splice(i,1);
          lives -=1;
          updateHUD();
          if(lives <= 0) running = false;
        }
      }

      // enemy <> player collision
      for(let i=enemies.length-1;i>=0;i--){
        if(collides(enemies[i], player)){ 
          enemies.splice(i,1);
          lives -=1;
          updateHUD();
          if(lives <= 0) running = false;
        }
      }

      // spawn timer -> spawn new enemies / waves
      spawnTimer -= dt * 1000;
      if(spawnTimer <= 0){
        const count = Math.min(8, 3 + Math.floor(wave/1.2));
        spawnEnemyRow(count);
        spawnTimer = spawnInterval;
        // after several spawns increase difficulty slightly
        spawnInterval = Math.max(500, spawnInterval - 20);
        wave++;
        updateHUD();
      }
    }

    function draw(){
      // clear
      ctx.fillStyle = '#061021';
      ctx.fillRect(0,0,W,H);

      // stars (simple background)
      ctx.fillStyle = '#06243a';
      for(let i=0;i<40;i++){
        const sx = (i*73) % W;
        const sy = (i*37 + Math.floor(perf%100)) % H;
        ctx.fillRect(sx, sy, 1,1);
      }

      // draw player (pixel-style)
      drawRect(Math.round(player.x), Math.round(player.y), player.w, player.h, '#9fe8ff');
      // small cockpit
      drawRect(Math.round(player.x+3), Math.round(player.y-2), 6, 3, '#bff6ff');

      // draw bullets
      ctx.fillStyle = '#fff9b0';
      bullets.forEach(b => drawRect(Math.round(b.x), Math.round(b.y), b.w, b.h, '#fff9b0'));

      // draw enemy bullets
      enemyBullets.forEach(b => drawRect(Math.round(b.x), Math.round(b.y), b.w, b.h, '#ffb2b2'));

      // draw enemies
      enemies.forEach(e => {
        drawRect(Math.round(e.x), Math.round(e.y), e.w, e.h, '#ffd37a');
        // eyes
        drawRect(Math.round(e.x+2), Math.round(e.y+2), 2,2, '#5b2a2a');
        drawRect(Math.round(e.x+8), Math.round(e.y+2), 2,2, '#5b2a2a');
      });

      // UI messages
      if(!running){
        drawCenteredText("GAME OVER", H/2 - 8, '#ff8a8a', 2);
        drawCenteredText("Press R to restart", H/2 + 12, '#cfe9ff', 1);
      } else if(gamePaused){
        drawCenteredText("PAUSED", H/2 - 6, '#cfe9ff', 2);
      }
    }

    function drawRect(x,y,w,h,color){
      ctx.fillStyle = color;
      ctx.fillRect(x,y,w,h);
    }

    function drawCenteredText(text, y, color='#fff', scale=1){
      ctx.fillStyle = color;
      ctx.font = `${8*scale}px monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(text, W/2, y);
      ctx.textAlign = 'left';
    }

    function gameLoop(now){
      const dt = Math.min(60, now - lastTime) / 16.6667; // approx frames relative to 60fps
      update(dt);
      draw();
      lastTime = now;
      requestAnimationFrame(gameLoop);
    }

    // input
    window.addEventListener('keydown', e=>{
      keys[e.key] = true;
      if(e.key === 'p' || e.key === 'P'){ gamePaused = !gamePaused; }
      if(e.key === 'r' || e.key === 'R'){ resetGame(); }
      if(e.code === 'Space') keys[' '] = true;
    });
    window.addEventListener('keyup', e=>{
      keys[e.key] = false;
      if(e.code === 'Space') keys[' '] = false;
    });

    restartBtn.addEventListener('click', resetGame);

    // Mobile control wiring (pointer events work for mouse + touch)
    function pointerDownHandler(key){
      return (ev) => {
        ev.preventDefault();
        keys[key] = true;
      };
    }
    function pointerUpHandler(key){
      return (ev) => {
        ev.preventDefault();
        keys[key] = false;
      };
    }

    // left/right buttons hold for continuous movement
    btnLeft.addEventListener('pointerdown', pointerDownHandler('ArrowLeft'));
    btnLeft.addEventListener('pointerup', pointerUpHandler('ArrowLeft'));
    btnLeft.addEventListener('pointercancel', pointerUpHandler('ArrowLeft'));
    btnLeft.addEventListener('lostpointercapture', pointerUpHandler('ArrowLeft'));

    btnRight.addEventListener('pointerdown', pointerDownHandler('ArrowRight'));
    btnRight.addEventListener('pointerup', pointerUpHandler('ArrowRight'));
    btnRight.addEventListener('pointercancel', pointerUpHandler('ArrowRight'));
    btnRight.addEventListener('lostpointercapture', pointerUpHandler('ArrowRight'));

    // shoot button: set space while pressed; allow tap/shoot
    btnShoot.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      keys[' '] = true;
    });
    btnShoot.addEventListener('pointerup', (e) => {
      e.preventDefault();
      keys[' '] = false;
    });
    btnShoot.addEventListener('pointercancel', (e) => {
      e.preventDefault();
      keys[' '] = false;
    });

    // Restart button on mobile
    btnRestart.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      // short visual feedback: briefly add active style
      resetGame();
    });
    btnRestart.addEventListener('pointerup', (e) => { e.preventDefault(); });
    btnRestart.addEventListener('pointercancel', (e) => { e.preventDefault(); });

    // Allow tapping canvas to shoot, and dragging to move ship (touch)
    canvas.addEventListener('pointerdown', (e) => {
      // quick tap -> one shot
      if(e.pointerType === 'touch'){
        // If tap with little movement, fire a single shot
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (W / rect.width);
        // If tap is on left/right half, move a bit toward that side for immediate feedback
        if(x < W/2) { player.x = Math.max(0, player.x - 6); }
        else { player.x = Math.min(W - player.w, player.x + 6); }
        // fire once
        bullets.push({ x: player.x + player.w/2 - 1, y: player.y - 4, w:2, h:4, vy: -2.6 });
      } else {
        // desktop pointer -> set space for quick shot
        keys[' '] = true;
        setTimeout(()=> keys[' '] = false, 60);
      }
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointerup', (e) => {
      try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
      keys[' '] = false;
    });

    // drag on canvas to control horizontal position directly (smooth on touch)
    canvas.addEventListener('touchmove', (e) => {
      // Touchmove handler to move player directly under finger
      if(e.touches && e.touches.length > 0){
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const px = (t.clientX - rect.left) * (W / rect.width) - player.w/2;
        player.x = Math.max(0, Math.min(W - player.w, px));
      }
      e.preventDefault();
    }, {passive:false});

    // Also allow mouse dragging using pointermove when pointer is down
    let mouseDownOnCanvas = false;
    canvas.addEventListener('pointermove', (e) => {
      if(e.pressure === 0 && e.pointerType === 'mouse') return;
      if(e.buttons === 0 && e.pointerType === 'mouse') return;
      const rect = canvas.getBoundingClientRect();
      const px = (e.clientX - rect.left) * (W / rect.width) - player.w/2;
      player.x = Math.max(0, Math.min(W - player.w, px));
    });

    // Resize / integer scale to keep pixelated look and keep it fitting mobile screens
    function updateScale(){
      const maxWidth = Math.max(120, window.innerWidth - 32);
      const maxHeight = Math.max(120, window.innerHeight - 160);
      const scaleX = Math.floor(maxWidth / W);
      const scaleY = Math.floor(maxHeight / H);
      let s = Math.max(1, Math.min(scaleX || 1, scaleY || 1));
      // Clamp scale to a reasonable max (avoid extremely large)
      s = Math.min(s, 8);
      document.documentElement.style.setProperty('--scale', s);
      // Also set game-wrap width to match scaled canvas
      const gameWrap = document.getElementById('game-wrap');
      if(gameWrap) gameWrap.style.width = (W * s) + 'px';
    }
    window.addEventListener('resize', updateScale);
    window.addEventListener('orientationchange', () => setTimeout(updateScale, 120));
    updateScale();

    // prevent page scroll when interacting with game area on mobile
    window.addEventListener('touchmove', function(e){
      // if touch is inside canvas or mobile controls, prevent scroll
      const t = e.target;
      if(t === canvas || t.closest('.mobile-controls') || t.closest('#game-wrap')) {
        e.preventDefault();
      }
    }, {passive:false});

    // initial spawn
    resetGame();
    // prime: spawn first small wave immediately
    spawnEnemyRow(4);
    updateHUD();

    // small performance counter for stars animation
    let perf = 0;
    setInterval(()=>perf=(perf+1)%100, 1000/15);

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
